#!/usr/bin/env python3
import subprocess
import asyncio
import aiohttp
import json
import os
import sys
import time
from pathlib import Path
import re
from typing import Dict, Optional, List, Tuple
import platform
import psutil
from datetime import datetime
import shutil

# Try to install required packages
def ensure_packages():
    required_packages = ["aiohttp", "psutil", "rich", "pyfiglet"]
    
    for pkg in required_packages:
        try:
            __import__(pkg)
        except ImportError:
            print(f"ƒêang c√†i package thi·∫øu: {pkg}")
            try:
                subprocess.run([sys.executable, "-m", "pip", "install", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"L·ªói khi c√†i {pkg}: {e}")
                sys.exit(1)

ensure_packages()

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.layout import Layout
from rich import box
import pyfiglet

console = Console()
CONFIG_PATH = Path(__file__).parent / "multi_configs.json"

class Utils:
    @staticmethod
    def ensure_root():
        try:
            if os.getuid() != 0:
                print("C·∫ßn quy·ªÅn root, chuy·ªÉn qua su...")
                # D√πng full path ƒë·ªÉ tr√°nh l·ªói m√¥i tr∆∞·ªùng PATH khi su
                python_path = "/data/data/com.termux/files/usr/bin/python"
                subprocess.run(f"su -c '{python_path} {__file__}'", shell=True, check=True)
                sys.exit(0)
        except AttributeError:

            pass
        except subprocess.CalledProcessError as e:
            print(f"Kh√¥ng th·ªÉ ch·∫°y v·ªõi quy·ªÅn root: {e}")
            sys.exit(1)

    @staticmethod
    def enable_wake_lock():
        try:
            subprocess.run("termux-wake-lock", shell=True, check=False)
            print("Wake lock b·∫≠t ‚ö°")
        except:
            print("Kh√¥ng b·∫≠t ƒë∆∞·ª£c wake lock üòÖ")

    @staticmethod
    async def kill_app(package_name: str):
        try:
            print(f"üíÄ [{package_name}] ƒêang kill app...")
            subprocess.run(f"am force-stop {package_name}", shell=True, check=False, 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"‚úÖ [{package_name}] ƒê√£ kill th√†nh c√¥ng!")
            # ƒê·ª£i 1 gi√¢y ƒë·ªÉ ƒë·∫£m b·∫£o app ƒë√£ ƒë√≥ng ho√†n to√†n
            await asyncio.sleep(1)
        except Exception as e:
            print(f"‚ùå [{package_name}] L·ªói khi kill app: {e}")

    @staticmethod
    async def launch(place_id: str, link_code: Optional[str], package_name: str):
        url = f"roblox://placeID={place_id}"
        if link_code:
            url += f"&linkCode={link_code}"
        
        print(f"üöÄ [{package_name}] ƒêang m·ªü: {url}")
        if link_code:
            print(f"‚ú® [{package_name}] ƒê√£ join b·∫±ng linkCode: {link_code}")

        # Determine activity based on package
        if package_name in ["com.roblox.client", "com.roblox.client.vnggames"]:
            activity = "com.roblox.client.ActivityProtocolLaunch"
        else:
            activity = "com.roblox.client.ActivityProtocolLaunch"

        command = f'am start -n {package_name}/{activity} -a android.intent.action.VIEW -d "{url}" --activity-clear-top'
        
        try:
            subprocess.run(command, shell=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"‚úÖ [{package_name}] Launch command executed!")
        except Exception as e:
            print(f"‚ùå [{package_name}] Launch failed: {e}")

    @staticmethod
    def ask(msg: str) -> str:
        return input(msg)

    @staticmethod
    def save_multi_configs(configs: Dict):
        try:
            with open(CONFIG_PATH, 'w', encoding='utf-8') as f:
                json.dump(configs, f, indent=2, ensure_ascii=False)
            print(f"üíæ ƒê√£ l∆∞u multi configs t·∫°i {CONFIG_PATH}")
        except Exception as e:
            print(f"‚ùå Kh√¥ng th·ªÉ l∆∞u configs: {e}")

    @staticmethod
    def load_multi_configs() -> Dict:
        if not CONFIG_PATH.exists():
            return {}
        try:
            with open(CONFIG_PATH, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}

    @staticmethod
    def detect_all_roblox_packages() -> Dict:
        packages = {}
        
        try:
            result = subprocess.run("pm list packages | grep com.roblox", 
                                  shell=True, capture_output=True, text=True)
            lines = [line for line in result.stdout.split('\n') if 'com.roblox' in line]
            
            for line in lines:
                match = re.search(r'package:(com\.roblox[^\s]+)', line)
                if match:
                    package_name = match.group(1)
                    
                    if package_name == 'com.roblox.client':
                        display_name = 'Roblox Qu·ªëc t·∫ø üåç'
                    elif package_name == 'com.roblox.client.vnggames':
                        display_name = 'Roblox VNG üáªüá≥'
                    else:
                        display_name = f'Roblox Custom ({package_name}) üéÆ'
                    
                    packages[package_name] = {
                        'packageName': package_name,
                        'displayName': display_name
                    }
        except Exception as e:
            print(f"‚ùå L·ªói khi qu√©t packages: {e}")

        return packages

    @staticmethod
    def get_roblox_cookie(package_name: str) -> Optional[str]:
        print(f"üç™ [{package_name}] ƒêang l·∫•y cookie ROBLOSECURITY...")
        
        try:
            # First method
            cmd = f"cat /data/data/{package_name}/app_webview/Default/Cookies | strings | grep ROBLOSECURITY"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            raw = result.stdout
        except:
            try:
                # Second method with su
                cmd = f"su -c sh -c 'cat /data/data/{package_name}/app_webview/Default/Cookies | strings | grep ROBLOSECURITY'"
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                raw = result.stdout
            except Exception:
                print(f"‚ùå [{package_name}] Kh√¥ng th·ªÉ ƒë·ªçc cookie b·∫±ng c·∫£ 2 c√°ch.")
                return None

        match = re.search(r'\.ROBLOSECURITY_([^\s/]+)', raw)
        if not match:
            print(f"‚ùå [{package_name}] Kh√¥ng t√¨m ƒë∆∞·ª£c cookie ROBLOSECURITY!")
            return None

        cookie_value = match.group(1).strip()
        if not cookie_value.startswith("_"):
            cookie_value = "_" + cookie_value
        
        return f".ROBLOSECURITY={cookie_value}"

class GameLauncher:
    @staticmethod
    async def handle_game_launch(should_launch: bool, place_id: str, link_code: Optional[str], 
                               package_name: str, rejoin_only: bool = False):
        if should_launch:
            print(f"üéØ [{package_name}] Starting launch process...")
            
            if not rejoin_only:
                # ƒê·ªìng b·ªô kill app tr∆∞·ªõc
                await Utils.kill_app(package_name)
            else:
                print(f"‚ö†Ô∏è [{package_name}] RejoinOnly mode - kh√¥ng kill app")

            # Sau ƒë√≥ m·ªõi launch
            await Utils.launch(place_id, link_code, package_name)
            
            print(f"‚úÖ [{package_name}] Launch process completed!")

class RobloxUser:
    def __init__(self, username: Optional[str] = None, user_id: Optional[int] = None, 
                 cookie: Optional[str] = None):
        self.username = username
        self.user_id = user_id
        self.cookie = cookie

    async def fetch_authenticated_user(self) -> Optional[int]:
        try:
            headers = {
                'Cookie': self.cookie,
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Termux)',
                'Accept': 'application/json',
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get("https://users.roblox.com/v1/users/authenticated", 
                                     headers=headers) as response:
                    if response.status == 200:
                        data = await response.json()
                        self.username = data['name']
                        self.user_id = data['id']
                        print(f"‚úÖ L·∫•y info th√†nh c√¥ng cho {self.username}!")
                        return self.user_id
                    else:
                        print(f"‚ùå HTTP Error: {response.status}")
                        return None
        except Exception as e:
            print(f"‚ùå L·ªói x√°c th·ª±c ng∆∞·ªùi d√πng: {e}")
            return None

    async def get_presence(self) -> Optional[Dict]:
        try:
            headers = {
                'Cookie': self.cookie,
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Termux)',
                'Accept': 'application/json',
            }
            
            data = {'userIds': [self.user_id]}
            
            async with aiohttp.ClientSession() as session:
                async with session.post("https://presence.roproxy.com/v1/presence/users",
                                      json=data, headers=headers) as response:
                    if response.status == 200:
                        result = await response.json()
                        return result.get('userPresences', [{}])[0] if result.get('userPresences') else None
                    return None
        except:
            return None

class GameSelector:
    def __init__(self):
        self.GAMES = {
            "1": ["126884695634066", "Grow-a-Garden üå±"],
            "2": ["2753915549", "Blox-Fruits üçá"],
            "3": ["6284583030", "Pet-Simulator-X üêæ"],
            "4": ["126244816328678", "DIG ‚õèÔ∏è"],
            "5": ["116495829188952", "Dead-Rails-Alpha üöÇ"],
            "6": ["8737602449", "PLS-DONATE üí∞"],
            "0": ["custom", "T√πy ch·ªânh ‚öôÔ∏è"],
        }

    async def choose_game(self) -> Dict:
        print("\nüéÆ Ch·ªçn game:")
        for k, v in self.GAMES.items():
            print(f"{k}. {v[1]} ({v[0]})")

        ans = Utils.ask("Nh·∫≠p s·ªë: ").strip()

        if ans == "0":
            sub = Utils.ask("0.1 ID th·ªß c√¥ng | 0.2 Link private redirect: ").strip()
            if sub == "1":
                pid = Utils.ask("Nh·∫≠p Place ID: ").strip()
                return {"placeId": pid, "name": "T√πy ch·ªânh ‚öôÔ∏è", "linkCode": None}
            elif sub == "2":
                print("\nüìé D√°n link redirect sau khi v√†o private server.")
                while True:
                    link = Utils.ask("\nD√°n link redirect ƒë√£ chuy·ªÉn h∆∞·ªõng: ")
                    match = re.search(r'/games/(\d+)[^?]*\?[^=]*=([\w-]+)', link)
                    if not match:
                        print("‚ùå Link kh√¥ng h·ª£p l·ªá!")
                        continue
                    return {
                        "placeId": match.group(1),
                        "name": "Private Server üîí",
                        "linkCode": match.group(2),
                    }
            raise ValueError("‚ùå Kh√¥ng h·ª£p l·ªá!")

        if ans in self.GAMES:
            return {
                "placeId": self.GAMES[ans][0],
                "name": self.GAMES[ans][1],
                "linkCode": None,
            }

        raise ValueError("‚ùå Kh√¥ng h·ª£p l·ªá!")

class StatusHandler:
    def __init__(self):
        self.has_launched = False
        self.joined_at = 0

    def analyze_presence(self, presence: Optional[Dict], target_root_place_id: str) -> Dict:
        now = int(time.time() * 1000)  # milliseconds

        if not presence or presence.get('userPresenceType') is None:
            return {
                'status': "Kh√¥ng r√µ ‚ùì",
                'info': "Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i ho·∫∑c thi·∫øu rootPlaceId",
                'shouldLaunch': True,  # Always try to rejoin when presence is unclear
                'rejoinOnly': False
            }

        # User is offline or away
        if presence.get('userPresenceType') in [0, 1]:
            return {
                'status': "Offline üí§",
                'info': "User offline! Ti·∫øn h√†nh rejoin! üöÄ",
                'shouldLaunch': True,  # Always rejoin when offline
                'rejoinOnly': False
            }

        # User is not in game (online but not playing)
        if presence.get('userPresenceType') != 2:
            return {
                'status': "Kh√¥ng online üò¥",
                'info': "User kh√¥ng trong game. ƒê√£ m·ªü l·∫°i game! üéÆ",
                'shouldLaunch': True,  # Always rejoin when not in game
                'rejoinOnly': False
            }

        # User is in game but wrong place
        root_place_id = presence.get('rootPlaceId')
        if not root_place_id or str(root_place_id) != str(target_root_place_id):
            return {
                'status': "Sai map üó∫Ô∏è",
                'info': f"User ƒëang trong game nh∆∞ng sai rootPlaceId ({root_place_id}). ƒê√£ rejoin ƒë√∫ng map! üéØ",
                'shouldLaunch': True,
                'rejoinOnly': True
            }

        # User is in correct game
        return {
            'status': "Online ‚úÖ",
            'info': "ƒêang ·ªü ƒë√∫ng game üéÆ",
            'shouldLaunch': False,
            'rejoinOnly': False
        }

    def update_join_status(self, should_launch: bool):
        if should_launch:
            self.joined_at = int(time.time() * 1000)
            self.has_launched = True

class UIRenderer:
    @staticmethod
    def get_system_stats() -> Dict:
        try:
            cpu_usage = psutil.cpu_percent(interval=0.1)
            memory = psutil.virtual_memory()
            total_gb = memory.total / (1024 ** 3)
            used_gb = (memory.total - memory.available) / (1024 ** 3)

            return {
                'cpuUsage': f"{cpu_usage:.1f}",
                'ramUsage': f"{used_gb:.2f}GB/{total_gb:.2f}GB"
            }
        except Exception as e:
            console.print("[red bold]L·ªói khi l·∫•y system stats:[/red bold]", e)
            return {
                'cpuUsage': "N/A",
                'ramUsage': "N/A"
            }

    @staticmethod
    def render_title() -> str:
        fallback_title = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üöÄ MULTI DAWN REJOIN üöÄ        ‚ïë
‚ïë           Auto Rejoin Tool           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"""
        try:
            try:
                title = pyfiglet.figlet_format("Multi Dawn", font="small")
            except Exception:
                console.print("[yellow]‚ö†Ô∏è Font 'small' l·ªói, d√πng font m·∫∑c ƒë·ªãnh[/yellow]")
                title = pyfiglet.figlet_format("Multi Dawn")
            
            with console.capture() as capture:
                console.print(title + "\nüöÄ REJOIN TOOL üöÄ", style="cyan")
            return capture.get()

        except Exception:
            console.print("[red bold]‚ùå L·ªói trong render_title():[/red bold]")
            traceback.print_exc()
            return fallback_title

    @staticmethod
    def format_countdown(seconds: int) -> str:
        return f"{seconds // 60}m {seconds % 60}s" if seconds >= 60 else f"{seconds}s"

    @staticmethod
    def render_multi_instance_table(instances: List[Dict]) -> str:
        try:
            stats = UIRenderer.get_system_stats()
            cpu_ram_line = f"üíª CPU: {stats['cpuUsage']}% | üß† RAM: {stats['ramUsage']} | üî• Instances: {len(instances)}"

            table = Table(show_header=True, header_style="bold cyan", box=box.ROUNDED)
            table.add_column("Package", style="dim", width=15)
            table.add_column("User", width=8)
            table.add_column("Status", width=12)
            table.add_column("Info", width=25)
            table.add_column("Time", width=8)
            table.add_column("Delay", width=6)

            for instance in instances:
                package_display = {
                    'com.roblox.client': 'Global üåç',
                    'com.roblox.client.vnggames': 'VNG üáªüá≥'
                }.get(instance.get('packageName', ''), instance.get('packageName', 'Unknown'))

                raw_username = instance.get('config', {}).get('username', 'Unknown')
                username = '*' * (len(raw_username) - 3) + raw_username[-3:] if len(raw_username) > 3 else raw_username

                delay_seconds = instance.get('countdownSeconds', 0)

                table.add_row(
                    package_display,
                    username,
                    instance.get('status', 'Unknown'),
                    instance.get('info', 'No info'),
                    datetime.now().strftime("%H:%M:%S"),
                    UIRenderer.format_countdown(delay_seconds)
                )

            with console.capture() as capture:
                console.print(cpu_ram_line)
                console.print(table)
            return capture.get()

        except Exception:
            console.print("[red bold]‚ùå L·ªói trong render_multi_instance_table():[/red bold]")
            traceback.print_exc()
            return "[L·ªói render table]"

    @staticmethod
    def display_configured_packages(configs: Dict) -> str:
        try:
            table = Table(show_header=True, header_style="bold cyan", box=box.ROUNDED)
            table.add_column("STT", width=5)
            table.add_column("Package", width=20)
            table.add_column("Username", width=15)
            table.add_column("Game", width=20)
            table.add_column("Delay", width=8)

            for index, (package_name, config) in enumerate(configs.items(), start=1):
                package_display = {
                    'com.roblox.client': 'Global üåç',
                    'com.roblox.client.vnggames': 'VNG üáªüá≥'
                }.get(package_name, package_name)

                username = config.get('username', 'Unknown')
                masked_username = '*' * (len(username) - 3) + username[-3:] if len(username) > 3 else username

                table.add_row(
                    str(index),
                    package_display,
                    masked_username,
                    config.get('gameName', 'Unknown'),
                    f"{config.get('delaySec', 0)}s"
                )

            with console.capture() as capture:
                console.print(table)
            return capture.get()

        except Exception:
            console.print("[red bold]‚ùå L·ªói trong display_configured_packages():[/red bold]")
            traceback.print_exc()
            return "[L·ªói render config table]"

class MultiRejoinTool:
    def __init__(self):
        self.instances = []
        self.is_running = False

    async def start(self):
        Utils.ensure_root()
        Utils.enable_wake_lock()

        os.system('clear' if os.name == 'posix' else 'cls')
        
        try:
            print(UIRenderer.render_title())
        except:
            print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üöÄ MULTI DAWN REJOIN üöÄ      ‚ïë
‚ïë           Auto Rejoin Tool           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù""")

        print("\nüéØ Multi-Instance Roblox Rejoin Tool")
        print("1. üöÄ B·∫Øt ƒë·∫ßu auto rejoin")
        print("2. ‚öôÔ∏è Setup packages")

        choice = Utils.ask("\nCh·ªçn option (1-2): ")

        if choice.strip() == "1":
            await self.start_auto_rejoin()
        elif choice.strip() == "2":
            await self.setup_packages()
        else:
            print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
            await asyncio.sleep(1)
            await self.start()

    async def setup_packages(self):
        print("\nüîç ƒêang qu√©t t·∫•t c·∫£ packages Roblox...")
        packages = Utils.detect_all_roblox_packages()
        
        if not packages:
            print("‚ùå Kh√¥ng t√¨m th·∫•y package Roblox n√†o!")
            return

        print("\nüì¶ T√¨m th·∫•y c√°c packages:")
        for index, pkg in enumerate(packages.values(), 1):
            print(f"{index}. {pkg['displayName']} ({pkg['packageName']})")

        configs = Utils.load_multi_configs()
        
        for package_name, package_info in packages.items():
            print(f"\n‚öôÔ∏è C·∫•u h√¨nh cho {package_info['displayName']}")
            
            cookie = Utils.get_roblox_cookie(package_name)
            if not cookie:
                print(f"‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie cho {package_name}, b·ªè qua...")
                continue

            user = RobloxUser(cookie=cookie)
            user_id = await user.fetch_authenticated_user()
            
            if not user_id:
                print(f"‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c user info cho {package_name}, b·ªè qua...")
                continue

            print(f"üë§ Username: {user.username}")
            print(f"üÜî User ID: {user_id}")

            selector = GameSelector()
            game = await selector.choose_game()

            while True:
                try:
                    delay_input = Utils.ask("‚è±Ô∏è Delay check (gi√¢y, 15-120): ")
                    delay_sec = int(delay_input)
                    if 15 <= delay_sec <= 120:
                        break
                    print("‚ùå Gi√° tr·ªã kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p l·∫°i.")
                except ValueError:
                    print("‚ùå Gi√° tr·ªã kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p l·∫°i.")

            configs[package_name] = {
                'username': user.username,
                'userId': user_id,
                'placeId': game['placeId'],
                'gameName': game['name'],
                'linkCode': game['linkCode'],
                'delaySec': delay_sec,
                'packageName': package_name
            }

            print(f"‚úÖ ƒê√£ c·∫•u h√¨nh xong cho {package_info['displayName']}!")

        Utils.save_multi_configs(configs)
        print("\n‚úÖ Setup ho√†n t·∫•t!")
        
        print("\n‚è≥ ƒêang quay l·∫°i menu ch√≠nh...")
        await asyncio.sleep(2)
        await self.start()

    async def start_auto_rejoin(self):
        configs = Utils.load_multi_configs()

        if not configs:
            print("‚ùå Ch∆∞a c√≥ config n√†o! Vui l√≤ng ch·∫°y setup packages tr∆∞·ªõc.")
            await asyncio.sleep(2)
            await self.start()
            return

        print("\nüìã Danh s√°ch packages ƒë√£ c·∫•u h√¨nh:")
        print(UIRenderer.display_configured_packages(configs))

        print("\nüéØ Ch·ªçn packages ƒë·ªÉ ch·∫°y:")
        print("0. üöÄ Ch·∫°y t·∫•t c·∫£ packages")

        package_list = []
        for index, (package_name, config) in enumerate(configs.items(), 1):
            if package_name == 'com.roblox.client':
                package_display = 'Global üåç'
            elif package_name == 'com.roblox.client.vnggames':
                package_display = 'VNG üáªüá≥'
            else:
                package_display = package_name

            print(f"{index}. {package_display} ({config['username']})")
            package_list.append(package_name)

        choice = Utils.ask("\nNh·∫≠p l·ª±a ch·ªçn (0 ƒë·ªÉ ch·∫°y t·∫•t c·∫£, ho·∫∑c s·ªë c√°ch nhau b·ªüi kho·∫£ng tr·∫Øng): ")
        
        if choice.strip() == "0":
            selected_packages = list(configs.keys())
            print("üöÄ S·∫Ω ch·∫°y t·∫•t c·∫£ packages!")
        else:
            try:
                indices = [int(x) - 1 for x in choice.strip().split() 
                          if x.isdigit() and 0 <= int(x) - 1 < len(package_list)]
                
                if not indices:
                    print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
                    await asyncio.sleep(1)
                    await self.start_auto_rejoin()
                    return

                selected_packages = [package_list[i] for i in indices]
                print("üéØ S·∫Ω ch·∫°y c√°c packages:")
                for i, pkg in enumerate(selected_packages, 1):
                    print(f"  - {i}. {pkg}")
            except (ValueError, IndexError):
                print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
                await asyncio.sleep(1)
                await self.start_auto_rejoin()
                return

        print("\nüöÄ Kh·ªüi t·∫°o multi-instance rejoin...")
        await self.initialize_selected_instances(selected_packages, configs)

    async def initialize_selected_instances(self, selected_packages: List[str], configs: Dict):
        # Initialize instances ch·ªâ cho c√°c packages ƒë∆∞·ª£c ch·ªçn
        for package_name in selected_packages:
            config = configs[package_name]
            cookie = Utils.get_roblox_cookie(package_name)
            
            if not cookie:
                print(f"‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie cho {package_name}, b·ªè qua...")
                continue

            user = RobloxUser(config['username'], config['userId'], cookie)
            status_handler = StatusHandler()

            self.instances.append({
                'packageName': package_name,
                'user': user,
                'config': config,
                'statusHandler': status_handler,
                'status': "Kh·ªüi t·∫°o... üîÑ",
                'info': "ƒêang chu·∫©n b·ªã...",
                'countdown': "00s",
                'lastCheck': 0,
                'presenceType': "Unknown",
                'countdownSeconds': 0
            })

        if not self.instances:
            print("‚ùå Kh√¥ng c√≥ instance n√†o kh·∫£ d·ª•ng!")
            return

        print(f"‚úÖ ƒê√£ kh·ªüi t·∫°o {len(self.instances)} instances!")
        print("‚è≥ B·∫Øt ƒë·∫ßu auto rejoin trong 3 gi√¢y...")
        await asyncio.sleep(3)
        
        self.is_running = True
        await self.run_multi_instance_loop()

    async def run_multi_instance_loop(self):
        render_counter = 0

        while self.is_running:
            now = int(time.time() * 1000)  # milliseconds

            for instance in self.instances:
                config = instance['config']
                user = instance['user']
                status_handler = instance['statusHandler']
                delay_ms = config['delaySec'] * 1000

                time_since_last_check = now - instance['lastCheck']

                # ƒê·∫øm ng∆∞·ª£c c√≤n bao nhi√™u gi√¢y n·ªØa th√¨ check l·∫°i
                time_left = max(0, delay_ms - time_since_last_check)
                instance['countdownSeconds'] = int((time_left + 999) // 1000)  # Ceiling division

                # N·∫øu ƒë·ªß th·ªùi gian th√¨ check
                if time_since_last_check >= delay_ms:
                    presence = await user.get_presence()

                    # Ghi l·∫°i type ƒë·ªÉ hi·ªÉn th·ªã
                    presence_type_display = "Unknown"
                    if presence and 'userPresenceType' in presence:
                        presence_type_display = str(presence['userPresenceType'])

                    analysis = status_handler.analyze_presence(presence, config['placeId'])

                    if analysis['shouldLaunch']:
                        await GameLauncher.handle_game_launch(
                            analysis['shouldLaunch'],
                            config['placeId'],
                            config['linkCode'],
                            config['packageName'],
                            analysis['rejoinOnly']
                        )
                        status_handler.update_join_status(analysis['shouldLaunch'])

                    instance['status'] = analysis['status']
                    instance['info'] = analysis['info']
                    instance['presenceType'] = presence_type_display
                    instance['lastCheck'] = now

                # N·∫øu ch∆∞a check l·∫ßn n√†o ho·∫∑c ch∆∞a set presenceType th√¨ gi·ªØ "Unknown"
                if not instance.get('presenceType'):
                    instance['presenceType'] = "Unknown"

            if render_counter % 5 == 0:
                os.system('clear' if os.name == 'posix' else 'cls')
                
                try:
                    print(UIRenderer.render_title())
                except:
                    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        üöÄ MULTI DAWN REJOIN üöÄ        ‚ïë
‚ïë           Auto Rejoin Tool           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù""")

                print(UIRenderer.render_multi_instance_table(self.instances))

                if self.instances:
                    print("\nüîç Debug (Instance 1):")
                    print(f"Package: {self.instances[0]['packageName']}")
                    print(f"Last Check: {datetime.fromtimestamp(self.instances[0]['lastCheck']/1000).strftime('%H:%M:%S')}")

                print("\nüí° Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng ch∆∞∆°ng tr√¨nh")

            render_counter += 1
            await asyncio.sleep(1)


def signal_handler(signum, frame):
    print('\n\nüõë ƒêang d·ª´ng ch∆∞∆°ng tr√¨nh...')
    print('üëã C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng Dawn Rejoin Tool!')
    sys.exit(0)


async def main():
    # Handle graceful shutdown
    import signal
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        tool = MultiRejoinTool()
        await tool.start()
    except KeyboardInterrupt:
        print('\n\nüõë ƒêang d·ª´ng ch∆∞∆°ng tr√¨nh...')
        print('üëã C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng Dawn Rejoin Tool!')
        sys.exit(0)


if __name__ == "__main__":
    asyncio.run(main())